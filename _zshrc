export GOROOT=(go env GOROOT)
export GOPATH="$HOME/.gopath"
export GOENV_ROOT="$HOME/.goenv"
export PYENV_ROOT="$HOME/.pyenv"
export EDITOR=nvim
export TERM=tmux-256color
export PATH="$GOPATH/bin:$PATH"
export PATH="$HOME/bin:$PATH"
export PATH="$HOME/dotfiles/bin:$PATH"
export PATH="$HOME/.nodebrew/current/bin:$PATH"
export PATH="$HOME/.pyenv/shims:$PATH"
export PATH="/usr/local/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/.goenv/bin:$PATH"
export ANACONDA_VERSION="anaconda3-2.5.0"

alias ovim=vim
alias vim=nvim
alias diff=colordiff
alias g=git
alias k=kubectl
alias kc=kubectl
alias kg='kubectl get'
alias kd='kubectl describe'
alias sudo='sudo '
alias ls=exa
alias ll='exa -l --git'
alias la='exa -la --git'
alias lt='exa -l -T --git'
alias syncon='tmux set-window-option synchronize-panes on'
alias syncoff='tmux set-window-option synchronize-panes off'
alias mon='eval $(minikube docker-env)'

function moff() {
  unset DOCKER_TLS_VERIFY
  unset DOCKER_HOST
  unset DOCKER_CERT_PATH
  unset DOCKER_API_VERSION
}

eval "$(direnv hook zsh)"
eval "$(pyenv init -)"
eval "$(goenv init -)"
powerline=$HOME/.pyenv/versions/anaconda3-2.5.0/bin/powerline-shell
function powerline_precmd() {
  PS1="$($powerline --shell zsh $?)"
}

function install_powerline_precmd() {
  for s in "${precmd_functions[@]}"; do
    if [ "$s" = "powerline_precmd" ]; then
      return
    fi
  done
  precmd_functions+=(powerline_precmd)
}

if [ "$TERM" != "linux" ]; then
  install_powerline_precmd
fi

export CLOUDSDK_PYTHON=$PYENV_ROOT/versions/$ANACONDA_VERSION/envs/py27/bin/python
source ~/google-cloud-sdk/path.zsh.inc
source ~/google-cloud-sdk/completion.zsh.inc
source ~/.python.sh
source ~/.gcp_commands.sh
if [[ -e ~/.cargo/env ]]; then
  source ~/.cargo/env
fi
#
export ZPLUG_HOME=/usr/local/opt/zplug
source $ZPLUG_HOME/init.zsh
zplug "zsh-users/zsh-completions"
zplug "zsh-users/zsh-syntax-highlighting"
zplug "zsh-users/zsh-history-substring-search"
zplug "peco/peco", as:command, from:gh-r, use:"*amd64*"
zplug "rupa/z"
zplug "Tarrasch/zsh-bd"
zplug "mollifier/cd-gitroot"
zplug load
function peco-history-selection() {
    BUFFER=`history -n 1 | tail -r  | awk '!a[$0]++' | peco`
    CURSOR=$#BUFFER
    PS1="$($powerline --shell zsh $?)"
    zle reset-prompt
}

export VIMODE='i'
function zle-keymap-select
{
  case $KEYMAP in
    main|viins)
      VIMODE='i';;
    vicmd)
      VIMODE='n';;
    vivis|vivli)
      VIMODE='v';;
  esac
  powerline_precmd
  zle reset-prompt
  }

zle -N zle-keymap-select

zle -N peco-history-selection
bindkey '^R' peco-history-selection
bindkey -v

# source ~/dotfiles/zsh/incr.zsh
# source ~/dotfiles/zsh/auto-fu.zsh; zle-line-init () { auto-fu-init; }; zle -N zle-line-init

# 自動補完を有効にする
# コマンドの引数やパス名を途中まで入力して <Tab> を押すといい感じに補完してくれる
# 例： `cd path/to/<Tab>`, `ls -<Tab>`
# autoload -U compinit; compinit

# 入力したコマンドが存在せず、かつディレクトリ名と一致するなら、ディレクトリに cd する
# 例： /usr/bin と入力すると /usr/bin ディレクトリに移動
setopt auto_cd

# cd した先のディレクトリをディレクトリスタックに追加する
# ディレクトリスタックとは今までに行ったディレクトリの履歴のこと
# `cd +<Tab>` でディレクトリの履歴が表示され、そこに移動できる
setopt auto_pushd

# pushd したとき、ディレクトリがすでにスタックに含まれていればスタックに追加しない
setopt pushd_ignore_dups

# 拡張 glob を有効にする
# glob とはパス名にマッチするワイルドカードパターンのこと
# （たとえば `mv hoge.* ~/dir` における "*"）
# 拡張 glob を有効にすると # ~ ^ もパターンとして扱われる
# どういう意味を持つかは `man zshexpn` の FILENAME GENERATION を参照
setopt extended_glob

# 入力したコマンドがすでにコマンド履歴に含まれる場合、履歴から古いほうのコマンドを削除する
# コマンド履歴とは今まで入力したコマンドの一覧のことで、上下キーでたどれる
setopt hist_ignore_all_dups

# コマンドがスペースで始まる場合、コマンド履歴に追加しない
# 例： <Space>echo hello と入力
setopt hist_ignore_space

# <Tab> でパス名の補完候補を表示したあと、
# 続けて <Tab> を押すと候補からパス名を選択できるようになる
# 候補を選ぶには <Tab> か Ctrl-N,B,F,P
zstyle ':completion:*:default' menu select=1

# setopt   auto_list auto_param_slash list_packed rec_exact
# unsetopt list_beep
# zstyle ':completion:*' menu select
# zstyle ':completion:*' format '%F{white}%d%f'
# zstyle ':completion:*' group-name ''
# zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
# zstyle ':completion:*' keep-prefix
# zstyle ':completion:*' completer _oldlist _complete _match _ignored _approximate _list _history
# autoload -U compinit
# compinit

# 単語の一部として扱われる文字のセットを指定する
# ここではデフォルトのセットから / を抜いたものとする
# こうすると、 Ctrl-W でカーソル前の1単語を削除したとき、 / までで削除が止まる
WORDCHARS='*?_-.[]~=&;!#$%^(){}<>'

# function () {
#     local code
#     code=${functions[auto-fu-init]/'\n-azfu-'/''}
#     eval "function auto-fu-init () { $code }"
#     code=${functions[auto-fu]/fg=black,bold/fg=white}
#     eval "function auto-fu () { $code }"
# }
